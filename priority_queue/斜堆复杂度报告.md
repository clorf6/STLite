## 斜堆复杂度报告

#### 定义

斜堆作为一个自适应堆，可以看作一个左偏树的变种，也能在均摊 $O(\log n)$ 的时间下支持插入、删除、合并操作，因此可以用来实现优先队列。实际上它与左偏树唯一的区别在于它并没有维护“左偏”的性质，在合并完成后选择直接交换左右子树。

#### 操作

* 合并 `merge`

  斜堆的合并操作与左偏树非常相似，操作步骤具体如下：

  1. 如果空斜堆和非空斜堆合并，返回非空斜堆；
  2. 如果两个斜堆均非空，则比较根节点，将较小的根节点（默认维护的是小根堆）的右儿子对应的子堆与另一个堆合并，并将合并后得到的新的子堆的根节点作为新的右儿子；
  3. 直接交换当前节点的左右儿子。
  
  最后一步就是斜堆的关键所在，粗略来说，我们每次合并就是交替地在左右子堆上插入新的结点，因此可以保证均摊复杂度。
  
  下证明合并的均摊复杂度为 $O(\log n)$。
  
  定义右路径为从一直往右走的路径，容易发现合并的结点都是某条右路径上的结点。定义重结点为右儿子的子堆中结点数量大于左儿子的子堆中结点数量的结点，否则为轻结点。定义势能 $\Phi$ 为所有结点出发的右路径上的重结点个数之和，显然个数之和是非负的，说明势能非负。
  
  考虑正在合并的两个结点为 $x,y$，设它们出发的右路径上轻结点个数分别为 $l_{x},l_{y}$，重结点个数分别为 $h _{x},h _{y}$。由于合并的结点都是这两条右路径上的结点，因此合并的实际代价为 $l _{x}+l _{y}+h _{x}+h _{y}$。
  
  现在考虑势能变化。在右路径上，对于重结点而言，它们的右儿子本来就比左儿子要大，而合并又发生在右儿子，因此合并后右儿子仍比左儿子大，但是交换后就会导致左儿子大于右儿子，此时这个重结点就变成了一个轻结点。对于轻节点而言，右儿子比左儿子小，我们无法确认合并后右儿子与左儿子谁大，因此不能确认轻节点合并后会不会变成重结点。我们考虑最坏的情况（即势能变化最大的情况），假设所有的轻节点都变成了重节点，那么此时势能变化量即为 $\Delta \Phi =l_{x}+l_{y}-h _{x}-h_{y}$。
  
  由于均摊代价等于实际代价和势能变化量的和，可以得到均摊代价即为 $2(l_{x}+l_{y})$。而 $l _{x},l _{y}$ 都不超过 $\log n$，证明很简单，类似于轻重链剖分，我们考虑某个轻结点 $u$，那么它的右儿子大小小于左儿子大小，因此右儿子的大小小于 $u$ 对应子堆的大小，也就是说从轻结点 $u$ 向右走一条边，对应的子树大小就会变成至多一半，因此右路径上经过的轻结点个数不超过 $\log n$。因此均摊复杂度为 $O(\log n)$。
  
* 入队 `push`

  入队操作基于合并操作完成。插入一个新的结点，可以理解成构建一个只含有这个新结点的斜堆，再将它合并到原来的斜堆上。复杂度也为 $O(\log n)$。

* 出队 `pop`

  将队首元素出队，即在斜堆中删除根节点，那么只用将根节点的左右儿子合并作为新的根节点即可。复杂度为 $O(\log n)$。
  
* 查询队首 `top`

  直接访问根节点即可，复杂度 $O(1)$。

* 查询队列大小 `size`

  对每个斜堆顺便维护一下大小就行，最终直接返回即可，复杂度 $O(1)$。

* 判断队列是否为空 `empty`
  
  判断大小是否为 $0$，复杂度 $O(1)$。

